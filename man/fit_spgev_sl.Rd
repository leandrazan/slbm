% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/fit_spgev_sl.R
\name{fit_spgev_sl}
\alias{fit_spgev_sl}
\title{Fit spatio-temporal GEV model based on sliding block maxima}
\usage{
fit_spgev_sl(
  data,
  loc.sp.form = ~1,
  scale.sp.form = ~1,
  loc.temp.form = NULL,
  scale.temp.form = NULL,
  spat.cov,
  start_vals = NULL,
  datastart = NULL,
  use_gr = FALSE,
  method = "BFGS",
  st_val_meth = "LeastSq",
  print_start_vals = TRUE,
  scale.link = make.link("log"),
  return_hessian = FALSE,
  ...
)
}
\arguments{
\item{data}{A nested tibble containing the unique sliding block maxima and their
frequency for the considered locations as obtained from the function
\code{\link[slbm]{get_uniq_bm}}.}

\item{loc.sp.form}{R formula definining the spatial model for the location parameter.}

\item{scale.sp.form}{R formula definining the spatial model for the scale parameter.}

\item{loc.temp.form}{R formula definining the temporal trend for the location parameter.}

\item{scale.temp.form}{R formula definining the temporal trend for the scale parameter.}

\item{spat.cov}{A data frame containing the spatial covariates used in the formulations
of the spatial formulas.}

\item{start_vals}{Optional; a vector containing initial values for the log Likelihood
which is to be optimised. If omitted, initial values are computed with
\code{\link[slbm]{get_start_vals}}.}

\item{datastart}{The data matrix on which starting values will be computed if
none are passed in \code{start_vals}.}

\item{use_gr}{Logical; whether to use theoretical gradient function when optimising.
Not working yet.}

\item{method}{The optimisation method that is passed to \code{optim()}. Defaults to "BFGS".}

\item{st_val_meth}{Method passed to \code{get_start_vals()} for cpmputing starting values if none
are provided.}

\item{print_start_vals}{Logical; whether to print out the initial parameter values.}

\item{scale.link}{The link function that is used to model the scale parameter.
Defaults to \eqn{log(\sigma) = \sigma_0 + \sigma_1 + ... }.}

\item{...}{Further arguments. These can be
\describe{
\item{temp.cov}{A numeric vector or matrix containing temporal covariates for the
data provided in \code{datastart} when needed to compute initial values. For more details,
see the documentation of \code{\link[slbm]{get_start_vals}}.}
\item{type}{
If you set \code{type  = "IF"}, coefficients will be fitted under the assumption
of constant dispersion parameter. In this case, any formulas passed concerning the location
parameter will be ignored and only the formulas concerning the scale parameter will be considered. }
\item{maxit, reltol ... }{Furhter components that are passed as a list to the
\code{control} argument of \code{optim()}.}
}}

\item{hessian}{Logical; Whether to return the hessian of the negative log-Likelihood.}
}
\value{
Returns a list containing the following components:
\describe{
\item{mle}{A numeric vector containing the estimated parameter values.}
\item{nllh}{The negative log-Likelihood evaluated at the estimated parameters.}
\item{conv}{The convergence code, inherited from \code{optim}.}
\item{counts}{A two-element integer vector giving the number of calls to the negative
log-Likelihood and its gradient, respectively, as obtained from optim.}
}
}
\description{
Fit spatio-temporal GEV model based on sliding block maxima
}
\examples{

######## prepare data ##########################################
data("ExampleData")
data("GMST")
tempcv <- GMST \%>\% dplyr::filter(Year \%in\% c(1980:2019))
tempcvsl <- rep(tempcv$smoothedGMST, each = 90)[1:(39*90 +1)]
tempcvsl <- data.frame(GMST = tempcvsl)
set.seed(3)
spatial_cvrt <- data.frame(lat  = seq(0, 8, length = 8),
   lon = runif(8), ele = runif(8))
yy <- data.frame(ExampleData) \%>\%
      tidyr::pivot_longer( 1:8, names_to = "Station", values_to = "Obs")
##############################
bmuniq <- get_uniq_bm(yy, 90, temp_cvrt = tempcvsl$GMST, looplastblock = FALSE)
# disjoint block maxima are used for computing starting values:
djbm <- apply(ExampleData, 2, blockmax, r = 90, "disjoint")
fit_spgev_sl(data = bmuniq, loc.sp.form = ~ lon + lat,
              scale.sp.form = ~ lon +lat,
              loc.temp.form = ~ GMST, spat.cov = spatial_cvrt,
              datastart = djbm, st_val_meth = "LeastSqTemp",
              temp.cov = tempcv$smoothedGMST, return_hess = TRUE)


}
