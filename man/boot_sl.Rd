% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/student_boot_sl.R
\name{boot_sl}
\alias{boot_sl}
\title{Studentized block bootstrap for sliding block maxima}
\usage{
boot_sl(
  sluniq,
  slorig,
  nKblocks,
  blcksz,
  B = 50,
  start_vals = NULL,
  type = "stationary",
  scale.link = scale.link,
  reltol = 1e-08,
  estimate_RL = TRUE,
  Tyrl = c(50, 100),
  ref_gmst = 0.8,
  varmeth = "V2",
  chain = TRUE,
  ...
)
}
\arguments{
\item{sluniq}{Sample of unique sliding block maxima with repsective frequency and
corresping covariate value (if type is not stationary)}

\item{slorig}{Sample of original sliding block maxima with
corresping covariate value (if type is not stationary)}

\item{nKblocks}{Number of Kblocks from which to bootstrap}

\item{blcksz}{The blocksize parameter}

\item{B}{The number of bootstrap repetitions}

\item{start_vals}{Starting values for the optimisation of the negative log-Likelihood of
the bootstrap sample.}

\item{type}{One of 'stationary', 'shift' or 'scale'.}

\item{scale.link}{Link function. Not implemented atm.}

\item{reltol}{Passed to optim.}

\item{estimate_RL}{One of \code{TRUE, FALSE} or \code{"both"}. If \code{FALSE},
only GEV parameter estimates are computed. If \code{TRUE}, only RL estimates are computed.
If \code{"both"}, both parameter and RL estimates are computed.}

\item{Tyrl}{The return periods for which RLs are estimated}

\item{ref_gmst}{Vector of reference values of the temporal covariate for which
RLs are estimated. Ignored when type is 'stationary'.}

\item{varmeth}{The method used to estimate the covariance matrix of GEV parameters: 'V', 'V2', or 'both'.}

\item{chain}{logical and only relevant for non-stationary models: Whether the method for
covariance estimation should be based on chain rule}

\item{...}{Further arguments passed to \code{fit_gev_univ}. When \code{type = scale}, one must
pass the logical argument \code{rel_trend} which specifies the parametrisation of the scale model.}
}
\value{

}
\description{
Studentized block bootstrap for sliding block maxima
}
\examples{
blcksz <- 90
ny <- 100
xx <-  evd::rgpd(ny*blcksz, shape = -0.2) + 2*rep(1:ny/ny, each = blcksz)
df.xx <- data.frame(Station = "X1", Obs = xx)
k <- 3
ndata <- blcksz * ny
.nKblocks <- ceiling(ndata/(k*blcksz))
indexblock <- data.frame(blockind = c(rep(1:(.nKblocks-1), each = k*blcksz),
                                      rep(.nKblocks, ndata - k*blcksz*(.nKblocks-1))),
                         obsind = 1:ndata)

sluniq_wb <- get_uniq_bm_boot(df.xx, blcksz = blcksz, indexblock = indexblock,
                              temp_cvrt = rep(1:ny/ny, each = blcksz), looplastblock = TRUE,
                              returnfullsamp = TRUE)

full_slbm <- sluniq_wb \%>\% dplyr::select(-uniq_data)
sluniq_wb <- sluniq_wb \%>\% dplyr::select(-full_data)


estim_lo <- slbm::fit_gev_univ(tidyr::unnest(sluniq_wb, cols = uniq_data),
 type = "shift", hessian = TRUE)

boot_sl(sluniq = sluniq_wb, slorig = full_slbm, blcksz = blcksz, nKblocks = .nKblocks,
B = 10, type = "shift", ref_gmst = (c(0.8, 0.9)), Tyrl = c(50, 100), start_vals = estim_lo$mle,
scale.link = make.link("identity"), reltol = 1e-09, estimate_RL = TRUE)
}
