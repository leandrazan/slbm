% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/get_start_vals.R
\name{get_start_vals}
\alias{get_start_vals}
\title{Compute initial values for ML fitting}
\usage{
get_start_vals(
  data,
  loc.sp.form = ~1,
  scale.sp.form = ~1,
  loc.temp.form = NULL,
  scale.temp.form = NULL,
  spat.cov,
  temp.cov = NULL,
  method = "LeastSq",
  print_start_vals = TRUE,
  scale.link = make.link("log"),
  ...
)
}
\arguments{
\item{data}{The data matrix from which initial GEV parameters are estimated.}

\item{loc.sp.form}{R formula definining the spatial model for the location parameter.}

\item{scale.sp.form}{R formula definining the spatial model for the scale parameter.}

\item{loc.temp.form}{R formula definining the temporal trend for the location parameter.}

\item{scale.temp.form}{R formula definining the temporal trend for the scale parameter.}

\item{spat.cov}{A data frame containing the spatial covariates used in the formulations
of the spatial formulas.}

\item{temp.cov}{A named matrix containing the temporal covariates used in the formulations
of the temporal formulas.}

\item{method}{The method used for computing initial values: One of "LeastSq",
"LeastSqTemp", "spatialGev", "fgevMean". See details for more information.}

\item{print_start_vals}{Logical; whether to print the initial parameters to the console.}

\item{scale.link}{The link function that is used for modelling the scale parameter.}

\item{...}{Further agruments that can be passed. Atm, the only supported further
argument is \code{type = "IF"} for computing initial values under homogeneity
constraint (Indexflood assumption).}
}
\value{
A vector containing a set of initial parameter values.
}
\description{
Compute initial values for ML fitting
}
\examples{
data("ExampleData")
data("GMST")
djbm <- apply(ExampleData, 2, blockmax, r = 90, "disjoint")

set.seed(3)
spatial_cvrt <- data.frame(lat  = seq(0, 8, length = 8),
   lon = runif(8), ele = runif(8))
tempcov <- GMST$smoothedGMST[101:140]
get_start_vals(djbm, loc.sp.form = ~ lon + lat, scale.sp.form = ~ lon + lat,
loc.temp.form = ~ GMST, scale.link = make.link("identity"),
spat.cov = spatial_cvrt, temp.cov = tempcov, method = "spatialGev")

}
