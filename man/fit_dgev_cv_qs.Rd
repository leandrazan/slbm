% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/fit_dgev_cv_qs.R
\name{fit_dgev_cv_qs}
\alias{fit_dgev_cv_qs}
\title{Cross-validation for d-GEV quantile estimation}
\usage{
fit_dgev_cv_qs(
  agg_bm,
  conc_bm,
  ds,
  quants = 1 - 1/c(50, 100),
  mult_sc = FALSE,
  dur_offset = FALSE,
  int_offset = FALSE,
  testset = "consec",
  n.lo = 3,
  n.cv = NULL,
  method = "both",
  returnLO = FALSE,
  optimMethod = "Nelder-Mead",
  Maxit = 1500,
  ...
)
}
\arguments{
\item{agg_bm}{Tibble as obtained from the output of \code{\link[=get_agg_bm()]{get_agg_bm()()}}.}

\item{conc_bm}{Tibble of sliding block maxima for all possible combinations of
years/seasons that are consecutive after removing observations from a year/season
for the test set}

\item{ds}{Vector of durations for which quantile of the d-GEV is estimated.}

\item{quants}{Vector of quantiles to estimate based on the d-GEV fit.}

\item{mult_sc}{logical. Whether to fit a multi-scale parameter eta2}

\item{dur_offset}{logical. Whether to fit a duration offset parameter theta}

\item{int_offset}{logical. Whether to fit an intensity offset parameter tau}

\item{testset}{Specifies how to construct the test set: either "consec", when test data
consists of maxima from consecutive years/seasons, such that the test sets are disjoint;
or 'random', when from all possible combinations of indices that can be left out, a random subset
of length 'n.cv' is sampled.}

\item{n.lo}{The amount of indices (i.e. how many years/seasons) you want to use to construct one test set}

\item{n.cv}{Only to be specified when 'testset = "random" ': specifies how many random test sets
to choose for cross-validation.}

\item{method}{Specifies which estimation method to use: must be
one of "disjoint", "sliding" or "both" (default).}

\item{returnLO}{Whether or not (default) the output should have an additional column containing the indices
of the years/seasons that the respective test set consists of. Note that the output already
has a colum with containing the test set (the values only, no indices).}

\item{optimMethod}{Optimisation method used in \code{\link[=optim]{optim()}}.}

\item{Maxit}{Passed to the control argument of \code{\link[=optim]{optim()}}:
maximum number of iterations performed during the optimisation.}

\item{...}{Further arguments that can be passed to the control argument of \code{\link[=optim]{optim()}}.}
}
\value{
Returns a tibble of dimension
\code{length(quants)}\eqn{ \times } \code{length(ds)} \eqn{\times} \eqn{n_{cv} \times 2 },
where \eqn{n_cv} is either the amount of possible testsets when the method for constructing the
test sets is \code{consec}, or as specified in the argument \code{n.cv} when \code{testset = "random" }.
The tibble contains the estimated parameters, the estimation method,
a code for the convergence (zero indicates successful convergence), the values of \eqn{p} for
which quantiles are estimated, the values of the durations \eqn{d} for which
quantiles are estimated, the test set (data that is used for computing the quantile score)
and the quantile score. Quantile Scores can only be computed for those durations which are also
present in the testdata.
}
\description{
Cross-validation for d-GEV quantile estimation
}
\examples{
dates <- seq(as.POSIXct("2000-01-01 00:00:00"),
as.POSIXct("2020-12-31 23:00:00"),by = 'hour')
prec <- rgamma(length(dates), shape = 0.1)
example_data <- data.frame(datetime = dates, prec = prec)

agbm <- get_agg_bm(example_data, ds = c(1,2,4,8,16, 24, 48))
agdf <- fun_aggregate2df( example_data, ds = c(1,2,4,8,16, 24, 48) )
concbm <- compute_conc_bm_id(agdf, testset = "consec")
cvres <- fit_dgev_cv_qs(agbm, concbm,  ds = c(1,4,8, 24))
# compute mean quantile scores based on cross-validation:
cvres \%>\% dplyr::select( - c( mut, sigma0, shape, eta, conv, Testdata )) \%>\%
          dplyr::group_by(ds, ps, estimator) \%>\%
          dplyr::summarise(MQS = mean(quant_score), .groups = "drop")
}
