}
}))
shapeabl <- Reduce("+", yy$shapeabl)
dermat <- (cbind(locabl, scaleabl, shapeabl))/nrow(xx)
dermat
}
scorefun_spat(params = params, loc.sp.form = ~ lon + lat, scale.sp.form = ~ lon +lat,
spat.cov = spatial_cvrt, origslbm = origslbm)
params.sp <- list(loc = params[startsWith(names(params),"loc")],
scale = params[startsWith(names(params),"scale")],
shape = params[startsWith(names(params),"shape")])
params.temp <- list(loc = params[startsWith(names(params),"tempLoc")],
scale = params[startsWith(names(params),"tempScale")])
params.temp <- purrr::map(params.temp, function(.x) ifelse(length(.x) == 0, 0, .x) )
# model matrices
model.loc.sp <- model.matrix(loc.sp.form, model.frame(loc.sp.form,
data = spat.cov, na.action = na.pass))
model.scale.sp <- model.matrix(scale.sp.form, model.frame(scale.sp.form,
data = spat.cov, na.action = na.pass))
# model matrices
model.loc.sp
# values of paramters
loc_sp <- data.frame(loc_sp = model.loc.sp %*% params.sp$loc)
loc_sp
scale_sp
scale_sp <-  data.frame(scale_sp = scale.link$linkinv(model.scale.sp %*% params.sp$scale))
scale_sp
scale.link
scale_sp
model.scale.sp
ny <- 50
blcksz <- 90
spatial_cvrt <- data.frame(lat  = seq(0, 8, length = 8),
lon = runif(8), ele = runif(8))
coords <- cbind(spatial_cvrt$lat, spatial_cvrt$lon)
colnames(coords ) <- c("lat", "lon")
mdax <- MDAdata(ny*blcksz, locations = coords, margins = list(distr = "gpd", shape = -0.2),
ms = list(kovmod = "whitmat", nugget = 0, range = 3, smooth = 0.44))
xx <- sim_spatial(mdax, params = c("loc0" = 10, "loc1" = 2, "loc2" = 0.05,
"scale0" = 2, "scale1" = 0.2, "shape" = -0.2),
loc.sp.form = ~ lon + lat, scale.sp.form = ~ lon,
spat.cov = spatial_cvrt)
origslbm <- apply(xx, 2, blockmax, r = 90, "sliding")
origslbm <- reshape2::melt(origslbm)
origslbm <- rename(origslbm, "Obs" = "value", "Station" = "Var2") %>% dplyr::select(-Var1)
yy <- data.frame(xx) %>%
tidyr::pivot_longer( 1:8, names_to = "Station", values_to = "Obs")
##############################
bmuniq <- get_uniq_bm(yy, 90,  looplastblock = TRUE)
params <-  fit_spgev_sl(data = bmuniq, loc.sp.form = ~ lon + lat,
scale.sp.form = ~ lon +lat,
spat.cov = spatial_cvrt,
datastart = djbm, st_val_meth = "LeastSq",
scale.link = make.link("identity"),
return_hess = TRUE)$mle
scorefun_spat(params = params, loc.sp.form = ~ lon + lat, scale.sp.form = ~ lon +lat,
spat.cov = spatial_cvrt, origslbm = origslbm)
scorefun_spat <- function(params, loc.sp.form, scale.sp.form,
loc.temp.form = NULL, scale.temp.form = NULL,
origslbm, spat.cov, scale.link = make.link("identity")){
params.sp <- list(loc = params[startsWith(names(params),"loc")],
scale = params[startsWith(names(params),"scale")],
shape = params[startsWith(names(params),"shape")])
params.temp <- list(loc = params[startsWith(names(params),"tempLoc")],
scale = params[startsWith(names(params),"tempScale")])
params.temp <- purrr::map(params.temp, function(.x) ifelse(length(.x) == 0, 0, .x) )
# model matrices
model.loc.sp <- model.matrix(loc.sp.form, model.frame(loc.sp.form,
data = spat.cov, na.action = na.pass))
model.scale.sp <- model.matrix(scale.sp.form, model.frame(scale.sp.form,
data = spat.cov, na.action = na.pass))
### to be implemented
if(!is.null(loc.temp.form)) {
loc.temp.form <- update(loc.temp.form,  ~ . + 0)
data <- data %>%
dplyr::mutate(MatLocTemp =  purrr::map(uniq_data, function(.x){
datatemp <-  data.frame(.x$temp_cvrt)
colnames(datatemp) <- all.vars(loc.temp.form)
model.matrix(loc.temp.form,
model.frame(loc.temp.form,
data = datatemp,
na.action = na.pass))
}
))
}
if(!is.null(scale.temp.form)) {
scale.temp.form <- update(scale.temp.form,  ~ . + 0)
data <- data %>%
dplyr::mutate(MatScaleTemp =  purrr::map(uniq_data, function(.x){
datatemp <-  data.frame(.x$temp_cvrt)
colnames(datatemp) <- all.vars(scale.temp.form)
model.matrix(scale.temp.form,
model.frame(scale.temp.form,
data = datatemp,
na.action = na.pass))
}
))
}
# values of paramters
loc_sp <- data.frame(loc_sp = model.loc.sp %*% params.sp$loc)
scale_sp <-  data.frame(scale_sp = scale.link$linkinv(model.scale.sp %*% params.sp$scale))
n.loc.sp <- ncol(model.loc.sp)
n.scale.sp <- ncol(model.scale.sp)
xx <- origslbm
xx <- xx %>% dplyr::group_by(Station) %>% tidyr::nest(data = Obs) %>%
dplyr::mutate(data = purrr::map(data, ~ .x$Obs)) %>%
dplyr::ungroup()
xx <- xx %>% dplyr::bind_cols(loc_sp, scale_sp)
# mutate value of (1+gamma*(x - mud)/sigmad)^(-1/gamma)
xx <- xx %>% dplyr::mutate(zd = purrr::pmap(list(data, loc_sp, scale_sp),
function(data, loc_sp, scale_sp) {
zz <- (data - loc_sp)/scale_sp
zz[ (1+params.sp$shape*zz) <=  0] <- NA
zz
}),
ud = purrr::map(zd,
function(x) {
if(abs(params.sp$shape) < 1e-08) {
exp( - x)
}
else {
(1+ params.sp$shape*x)^(-1/params.sp$shape)
}
}))
colnames(model.loc.sp) <- paste0("loc", 1:n.loc.sp)
yy <- xx %>% dplyr::bind_cols(model.loc.sp)
# mutate values of derivative of d/dmu_i loglik evaluated at observations with corresponding
#parameters
yy <- yy %>% dplyr::mutate_at(vars(paste0("loc", 1:n.loc.sp)),
~ purrr::pmap(list(ud,  scale_sp, .x),
function(ud,  scale_sp, .x) {
ud^(params.sp$shape +1) *.x /scale_sp *
( (params.sp$shape + 1)/ud -1) } )
)
# finally the sum over the d stations of the derivatives w.r.t. location
locabl <- (apply(yy[ ,paste0("loc", 1:n.loc.sp) ], 2, function(x) Reduce("+", x )))
# check:
# aa <- xx[1, ]$ud[[1]]^(params.sp$shape +1)*1/
#   xx[1,]$scale_sp[[1]]*( (params.sp$shape +1)/xx[1,]$ud[[1]] -1)
## same for scale derivative
## use xx from before
colnames(model.scale.sp) <- paste0("scale", 1:n.scale.sp)
yy <- xx %>% dplyr::bind_cols(model.scale.sp)
yy <- yy %>% dplyr::mutate_at(vars(paste0("scale", 1:n.scale.sp)),
~ purrr::pmap(list(zd, ud, loc_sp, scale_sp, .x),
function(zd, ud, loc_sp,  scale_sp, .x) {
ud^(params.sp$shape +1) *.x /scale_sp * zd*
( (params.sp$shape + 1)/ud -1 - 1/scale_sp) } ))
## check:
# aa <- xx[1, ]$ud[[1]]^(params.sp$shape +1)*model.scale.sp[1, 2]/
#   xx[1,]$scale_sp[[1]]^2*( xx[1, ]$data[[1]] - xx[1,]$loc_sp[[1]]) *
#  ((params.sp$shape +1)/xx[1,]$ud[[1]] -1 - 1/xx[1,]$scale_sp[[1]])
# finally the sum over the d stations of the derivatives w.r.t. scale
scaleabl <- (apply(yy[ ,paste0("scale", 1:n.scale.sp) ], 2, function(x) Reduce("+", x )))
## for derivative wrt shape
yy <- xx %>% dplyr::mutate(shapeabl = purrr::pmap(list(zd, ud, scale_sp, loc_sp),
function(zd, ud, scale_sp, loc_sp) {
xi <- params.sp$shape
if(abs(params.sp$shape) < 1e-08) {
(1-ud)*zd^2/2- zd
}
else {
(1-ud)*1/xi*(1/xi*log(1+xi*zd)-zd/(1+xi*zd)) - zd/(1+xi*zd)
}
}))
shapeabl <- Reduce("+", yy$shapeabl)
dermat <- (cbind(locabl, scaleabl, shapeabl))/nrow(xx)
dermat
}
scorefun_spat(params = params, loc.sp.form = ~ lon + lat, scale.sp.form = ~ lon +lat,
spat.cov = spatial_cvrt, origslbm = origslbm)
aa <- origslbm
compute_sl_cov_spat(aa, hessmat = hessmat$hessian,
blcksz = 90, varmeth = "V2")
hessmat <-  fit_spgev_sl(data = bmuniq, loc.sp.form = ~ lon + lat,
scale.sp.form = ~ lon +lat,
loc.temp.form = NULL, spat.cov = spatial_cvrt,
datastart = djbm, st_val_meth = "LeastSq",
scale.link = make.link("identity"),
temp.cov = tempcv$smoothedGMST, return_hess = TRUE)
hessmat <-  fit_spgev_sl(data = bmuniq, loc.sp.form = ~ lon + lat,
scale.sp.form = ~ lon +lat,
loc.temp.form = NULL, spat.cov = spatial_cvrt,
datastart = djbm, st_val_meth = "LeastSq",
scale.link = make.link("identity"), return_hess = TRUE)
compute_sl_cov_spat(aa, params = hessmat$mle, hessmat = hessmat$hessian,
blcksz = 90, varmeth = "V2", loc.sp.form = ~ lon + lat,
scale.sp.form = ~ lon + lat, spatial_cvrt = spatial_cvrt)
compute_sl_cov_spat(aa, params = hessmat$mle, hessmat = hessmat$hessian,
blcksz = 90, varmeth = "V2", loc.sp.form = ~ lon + lat,
scale.sp.form = ~ lon , spatial_cvrt = spatial_cvrt)
hessmat <-  fit_spgev_sl(data = bmuniq, loc.sp.form = ~ lon + lat,
scale.sp.form = ~ lon ,
loc.temp.form = NULL, spat.cov = spatial_cvrt,
datastart = djbm, st_val_meth = "LeastSq",
scale.link = make.link("identity"), return_hess = TRUE)
compute_sl_cov_spat(aa, params = hessmat$mle, hessmat = hessmat$hessian,
blcksz = 90, varmeth = "V2", loc.sp.form = ~ lon + lat,
scale.sp.form = ~ lon , spatial_cvrt = spatial_cvrt)
hessmat$hessian
hessmat <-  fit_spgev_sl(data = bmuniq, loc.sp.form = ~ lon + lat,
scale.sp.form = ~ lon ,
loc.temp.form = NULL, spat.cov = spatial_cvrt,
datastart = djbm, st_val_meth = "LeastSq",
scale.link = make.link("identity"), return_hess = TRUE)
hessmat
hessmat <-  fit_spgev_sl(data = bmuniq, loc.sp.form = ~ lon + lat,
scale.sp.form = ~ lon + lat ,
loc.temp.form = NULL, spat.cov = spatial_cvrt,
datastart = djbm, st_val_meth = "LeastSq",
scale.link = make.link("identity"), return_hess = TRUE)
hessmat
?fit_spgev_sl
?get_stat_vals
?get_start_vals
hessmat <-  fit_spgev_sl(data = bmuniq, loc.sp.form = ~ lon + lat,
scale.sp.form = ~ lon + lat ,
loc.temp.form = NULL, spat.cov = spatial_cvrt,
datastart = djbm, st_val_meth = "spatialGEV",
scale.link = make.link("identity"), return_hess = TRUE)
hessmat <-  fit_spgev_sl(data = bmuniq, loc.sp.form = ~ lon + lat,
scale.sp.form = ~ lon + lat ,
loc.temp.form = NULL, spat.cov = spatial_cvrt,
datastart = djbm, st_val_meth = "spatialGev",
scale.link = make.link("identity"), return_hess = TRUE)
bmuniq
hessmat <-  fit_spgev_sl(data = bmuniq, loc.sp.form = ~ lon,
scale.sp.form = ~ lon + lat ,
loc.temp.form = NULL, spat.cov = spatial_cvrt,
datastart = djbm, st_val_meth = "LeastSq",
scale.link = make.link("identity"), return_hess = TRUE)
hessmat
rm(list = ls())
devtools::load_all()
estimate_var_rl
est_var_univ
score.function_univ
devtools::load_all()
blcksz <- 90
xx <- evd::rgpd(100*90, shape = 0.2) + 1.2*rep(1:100/100, each = blcksz)
plot.ts(xx)
# define a temporal covariate that is constant over a block of length blcksz
temp_cvrt <- rep(1:100/100, each = blcksz)[1:(99*blcksz + 1)]
bmx <- slbm::blockmax(xx, 90, "sliding")
plot.ts(bmx)
bms <- get_uniq_bm(xx, blcksz, temp_cvrt = temp_cvrt, looplastblock = FALSE)
bms
mlest <- fit_gev_univ(bms, hessian = TRUE, type  = "shift")
mlest
aa <- score.function_univ(bmx, theta = mlest$mle, temp.cov = temp_cvrt, type = "shift")
dim(aa)
mus <- mlest$mle[1] + mlest$mle[4]*temp_cvrt
bmx_scaled <- (bmx - mus)/mlest$mle[2]
bb <- score.function_univ(bmx_scaled, theta = c("loc0" = 0,
"scale0" = 1,
"shape" = unname(mlest$mle[3]),
"tempLoc1" = 0),
temp.cov = temp_cvrt, type = "shift")
dim(bb)
plot.ts(t(aa- diag(c(1/mlest$mle[2],1/mlest$mle[2], 1, 1/mlest$mle[2]))%*%bb))
plot.ts(t(aa))
testfun_shift <- function(bmx, loc0, scale0, shape, alpha, tempcov) {
aa <- score.function_univ(bmx, theta = c(loc0, scale0, shape, alpha),
temp.cov = tempcov, type = "shift")
aa
}
dim(bb)
bb[ , 1:2]
score.function_univ(bmx_scaled[1], theta = c("loc0" = 0,
"scale0" = 1,
"shape" = unname(mlest$mle[3]),
"tempLoc1" = 0),
temp.cov = temp_cvrt, type = "shift")
score.function_univ(bmx_scaled[1], theta = c("loc0" = 0,
"scale0" = 1,
"shape" = unname(mlest$mle[3]),
"tempLoc1" = 0),
temp.cov = temp_cvrt[1], type = "shift")
mus
mus[1]
sigma0 <- mlest$mle[2]
testfun_shift((bmx[1] - mus[1])/sigma0,
loc0 = 0, scale0 = 1, shape = 0.1,
alpha = 0, tempcov = temp_cvrt[1])
score.function_univ
testfun_shift <- function(bmx, loc0, scale0, shape, alpha, tempcov) {
aa <- score.function_univ(bmx, theta = c("loc0" = loc0,
"scale0" = scale0, "shape" = shape,
"tempLoc1" = alpha),
temp.cov = tempcov, type = "shift")
aa
}
testfun_shift((bmx[1] - mus[1])/sigma0,
loc0 = 0, scale0 = 1, shape = 0.1,
alpha = 0, tempcov = temp_cvrt[1])
mu0 <- mlest$mle[1]
alpha0 <- mlest$mle[4]
numDeriv::grad(function(x) {testfun_shift((bmx[1] - mus[1])/sigma0,
loc0 = 0, scale0 = x, shape = 0.1,
alpha = 0, tempcov = temp_cvrt[1])[1]},
x = 1)/(numDeriv::grad(function(x) {testfunshift(bmx[1], loc0 = mu0,
scale0 = x, shape = 0.1,
alpha = alpha0, tempcov = temp_cvrt[1])[1]},
x = sigma0))
numDeriv::grad(function(x) {testfun_shift((bmx[1] - mus[1])/sigma0,
loc0 = 0, scale0 = x, shape = 0.1,
alpha = 0, tempcov = temp_cvrt[1])[1]},
x = 1)/(numDeriv::grad(function(x) {testfun_shift(bmx[1], loc0 = mu0,
scale0 = x, shape = 0.1,
alpha = alpha0, tempcov = temp_cvrt[1])[1]},
x = sigma0))
sigma0
alpha0
numDeriv::grad(function(x) {testfun_shift((bmx[1] - mus[1])/sigma0,
loc0 = 0, scale0 = x, shape = 0.1,
alpha = 0, tempcov = temp_cvrt[1])[1]},
x = 1)
(numDeriv::grad(function(x) {testfun_shift(bmx[1], loc0 = mu0,
scale0 = x, shape = 0.1,
alpha = alpha0, tempcov = temp_cvrt[1])[1]},
x = sigma0))
testfun_shift(bmx[1], loc0 = mu0,
scale0 = sigma0, shape = 0.1,
alpha = alpha0, tempcov = temp_cvrt[1])
sigma0 <- unname(mlest$mle[2])
mu0 <- unname(mlest$mle[1])
alpha0 <- unname(mlest$mle[4])
numDeriv::grad(function(x) {testfun_shift((bmx[1] - mus[1])/sigma0,
loc0 = 0, scale0 = x, shape = 0.1,
alpha = 0, tempcov = temp_cvrt[1])[1]},
x = 1)/(numDeriv::grad(function(x) {testfun_shift(bmx[1], loc0 = mu0,
scale0 = x, shape = 0.1,
alpha = alpha0, tempcov = temp_cvrt[1])[1]},
x = sigma0))
sigma0
sigma0^2
numDeriv::grad(function(x) {testfun_shift((bmx[1] - mus[1])/3,
loc0 = 0, scale0 = x, shape = 0.1,
alpha = 0, tempcov = temp_cvrt[1])[1]},
x = 1)/(numDeriv::grad(function(x) {testfun_shift(bmx[1], loc0 = mu0,
scale0 = x, shape = 0.1,
alpha = alpha0, tempcov = temp_cvrt[1])[1]},
x = 3))
numDeriv::grad(function(x) {testfun_shift((bmx[1] - mus[1])/3,
loc0 = 0, scale0 = x, shape = 0.1,
alpha = 0, tempcov = temp_cvrt[1])[2]},
x = 1)/(numDeriv::grad(function(x) {testfun_shift(bmx[1], loc0 = mu0,
scale0 = x, shape = 0.1,
alpha = alpha0, tempcov = temp_cvrt[1])[2]},
x = 3))
numDeriv::grad(function(x) {testfun_shift((bmx[1] - mus[1])/3,
loc0 = 0, scale0 = x, shape = 0.1,
alpha = 0, tempcov = temp_cvrt[1])[3]},
x = 1)/(numDeriv::grad(function(x) {testfun_shift(bmx[1], loc0 = mu0,
scale0 = x, shape = 0.1,
alpha = alpha0, tempcov = temp_cvrt[1])[3]},
x = 3))
numDeriv::grad(function(x) {testfun_shift((bmx[1] - mus[1])/3,
loc0 = 0, scale0 = x, shape = 0.1,
alpha = 0, tempcov = temp_cvrt[1])[4]},
x = 1)/(numDeriv::grad(function(x) {testfun_shift(bmx[1], loc0 = mu0,
scale0 = x, shape = 0.1,
alpha = alpha0, tempcov = temp_cvrt[1])[4]},
x = 3))
numDeriv::grad(function(x) {testfun_shift((bmx[1] - mus[1])/3,
loc0 = x, scale0 = 1, shape = 0.1,
alpha = 0, tempcov = temp_cvrt[1])[4]},
x = 0)/(numDeriv::grad(function(x) {testfun_shift(bmx[1], loc0 = x,
scale0 = 3, shape = 0.1,
alpha = alpha0, tempcov = temp_cvrt[1])[4]},
x = mu0))
numDeriv::grad(function(x) {testfun_shift((bmx[1] - mus[1])/3,
loc0 = x, scale0 = 1, shape = 0.1,
alpha = 0, tempcov = temp_cvrt[1])[1]},
x = 0)/(numDeriv::grad(function(x) {testfun_shift(bmx[1], loc0 = x,
scale0 = 3, shape = 0.1,
alpha = alpha0, tempcov = temp_cvrt[1])[1]},
x = mu0))
numDeriv::grad(function(x) {testfun_shift((bmx[1] - mus[1])/3,
loc0 = x, scale0 = 1, shape = 0.1,
alpha = 0, tempcov = temp_cvrt[1])[2]},
x = 0)/(numDeriv::grad(function(x) {testfun_shift(bmx[1], loc0 = x,
scale0 = 3, shape = 0.1,
alpha = alpha0, tempcov = temp_cvrt[1])[2]},
x = mu0))
numDeriv::grad(function(x) {testfun_shift((bmx[1] - mus[1])/3,
loc0 = x, scale0 = 1, shape = 0.1,
alpha = 0, tempcov = temp_cvrt[1])[3]},
x = 0)/(numDeriv::grad(function(x) {testfun_shift(bmx[1], loc0 = x,
scale0 = 3, shape = 0.1,
alpha = alpha0, tempcov = temp_cvrt[1])[3]},
x = mu0))
numDeriv::grad(function(x) {testfun_shift((bmx[1] - mus[1])/3,
loc0 = 0, scale0 = 1, shape = 0.1,
alpha = x, tempcov = temp_cvrt[1])[3]},
x = 0)/(numDeriv::grad(function(x) {testfun_shift(bmx[1], loc0 = mu0,
scale0 = 3, shape = 0.1,
alpha = x, tempcov = temp_cvrt[1])[3]},
x = alpha0))
numDeriv::grad(function(x) {testfun_shift((bmx[1] - mus[1])/3,
loc0 = 0, scale0 = 1, shape = 0.1,
alpha = x, tempcov = temp_cvrt[1])[4]},
x = 0)/(numDeriv::grad(function(x) {testfun_shift(bmx[1], loc0 = mu0,
scale0 = 3, shape = 0.1,
alpha = x, tempcov = temp_cvrt[1])[4]},
x = alpha0))
numDeriv::grad(function(x) {testfun_shift((bmx[1] - mus[1])/3,
loc0 = 0, scale0 = 1, shape = 0.1,
alpha = x, tempcov = temp_cvrt[1])[1]},
x = 0)/(numDeriv::grad(function(x) {testfun_shift(bmx[1], loc0 = mu0,
scale0 = 3, shape = 0.1,
alpha = x, tempcov = temp_cvrt[1])[1]},
x = alpha0))
numDeriv::grad(function(x) {testfun_shift((bmx[1] - mus[1])/3,
loc0 = 0, scale0 = 1, shape = 0.1,
alpha = x, tempcov = temp_cvrt[1])[2]},
x = 0)/(numDeriv::grad(function(x) {testfun_shift(bmx[1], loc0 = mu0,
scale0 = 3, shape = 0.1,
alpha = x, tempcov = temp_cvrt[1])[2]},
x = alpha0))
blcksz <- 90
blcksz <- 90
xx <- evd::rgpd(100*90, shape = 0.2)
mlx <- evd::fgev(xx)
mlx
mlx <- evd::fgev(xx)$estimate
mlx
xx <- ( xx- mlx[1])/mlx[2]
xx <- 2*exp(1.2*rep(1:100/100, each = blcksz)/2 ) + 4*exp(1.2*rep(1:100/100, each = blcksz)/2 )*xx
plot.ts(xx)
# define a temporal covariate that is constant over a block of length blcksz
temp_cvrt <- rep(1:100/100, each = blcksz)[1:(99*blcksz + 1)]
bmx <- slbm::blockmax(xx, 90, "sliding")
plot.ts(bmx)
bms <- get_uniq_bm(xx, blcksz, temp_cvrt = temp_cvrt, looplastblock = FALSE)
bms
mlest <- fit_gev_univ(bms, hessian = TRUE, type  = "scale")
mlest
blcksz <- 90
xx <- evd::rgpd(100*90, shape = 0.2)
mlx <- evd::fgev(xx)$estimate
mlx
xx <- ( xx- mlx[1])/mlx[2]
xx <- 2*exp(0.8*rep(1:100/100, each = blcksz)/2 ) +
4*exp(0.8*rep(1:100/100, each = blcksz)/2 )*xx
plot.ts(xx)
# define a temporal covariate that is constant over a block of length blcksz
temp_cvrt <- rep(1:100/100, each = blcksz)[1:(99*blcksz + 1)]
bmx <- slbm::blockmax(xx, 90, "sliding")
plot.ts(bmx)
bms <- get_uniq_bm(xx, blcksz, temp_cvrt = temp_cvrt, looplastblock = FALSE)
bms
mlest <- fit_gev_univ(bms, hessian = TRUE, type  = "scale")
mlest
aa <- score.function_univ(bmx, theta = mlest$mle, temp.cov = temp_cvrt, type = "scale")
dim(aa)
mus <- mlest$mle[1]*exp(mlest$mle[4]*temp_cvrt/mlest$mle[1])
sigmas <- mlest$mle[2]*exp(mlest$mle[4]*temp_cvrt/mlest$mle[1])
bmx_scaled <- (bmx - mus)/sigmas
bb <- score.function_univ(bmx_scaled, theta = c("loc0" = 0,
"scale0" = 1,
"shape" = unname(mlest$mle[3]),
"tempLoc1" = 0),
temp.cov = temp_cvrt, type = "scale")
dim(bb)
score.function_univ
bb <- score.function_univ(bmx_scaled, theta = c("mu0" = 0,
"sigma0" = 1,
"gamma" = unname(mlest$mle[3]),
"alpha" = 0),
temp.cov = temp_cvrt, type = "scale")
dim(bb)
dim(bmx_scaled)
length(bmx_scaled)
mlest$mle[3]
dim(aa)
mus
sigmas
bb <- score.function_univ(bmx_scaled, theta = c("mu0" = 0,
"sigma0" = 1,
"gamma" = unname(mlest$mle[3]),
"alpha" = 0),
temp.cov = temp_cvrt, type = "scale")
dim(bb)
bb <- score.function_univ(bmx_scaled, theta = c("mu0" = 1,
"sigma0" = 1,
"gamma" = unname(mlest$mle[3]),
"alpha" = 0),
temp.cov = temp_cvrt, type = "scale")
dim(bb)
plot.ts(t(aa- diag(c(1/mlest$mle[2],1/mlest$mle[2], 1, 1/mlest$mle[2]))%*%bb))
load_all()
bb <- score.function_univ(bmx_scaled, theta = c("mu0" = 0,
"sigma0" = 1,
"gamma" = unname(mlest$mle[3]),
"alpha" = 0),
temp.cov = temp_cvrt, type = "scale")
dim(bb)
load_all()
devtools::load_all()
bb <- score.function_univ(bmx_scaled, theta = c("mu0" = 0,
"sigma0" = 1,
"gamma" = unname(mlest$mle[3]),
"alpha" = 0),
temp.cov = temp_cvrt, type = "scale")
dim(bb)
plot.ts(t(aa- diag(c(1/mlest$mle[2],1/mlest$mle[2], 1, 1/mlest$mle[2]))%*%bb))
plot.ts(t(aa))
plot.ts(t(1/mlest$mle[2]*bb))
plot.ts(bb)
plot.ts(t(bb))
bb[ , 1:10]
