.f = function( .mut, .sigma0, .shape, .theta,
.eta, .eta2, .tau, .ps, .d){
IDF::qgev.d(.ps, mut = .mut, sigma0 = .sigma0, xi = .shape ,
eta = .eta , eta2 = (.eta2 + .eta), tau = .tau ,
theta = .theta, d = .d)
}
))
table_quants <- table_quants[ , !(colnames(table_quants) %in% rmcol)]
zns  <- agg_bm_test %>%
dplyr::select(-Year)
zns <- dplyr::rename(zns, "ds"= "duration")
zns <- zns %>% dplyr::group_by(ds) %>% tidyr::nest(Testdata = djdata)
table_quants <- dplyr::left_join(table_quants, zns, by = "ds")
table_quants <- table_quants %>%
dplyr::mutate( quant_score = purrr::pmap_dbl( .l = list( .ps = ps , .q = est.quants, .obs = Testdata),
.f = function(.ps, .q, .obs){
if(is.null(.obs)){ NA} else{
compute_qs(obs = unlist(.obs) , quant.est = .q,
p = .ps) }
})) %>%
dplyr::arrange(ps, ds)
return(table_quants)
}
tibres <- tibble::tibble(left_out = sbst)  %>%
dplyr::mutate( Result = purrr::map( left_out, .f = function(.x){
dgev_cv_fit(agg_bm = agg_bm, conc_bm = conc_bm, leave_out = .x, ds =  c(1,2,4,8,24,38,72),
quants = c(0.95, 0.99), mult_sc =F, dur_offset = F,
int_offset = F)
}))
tibres
fit_dgev_cv_qs(agg_bm = agbm, conc_bm = concbm, ds = durs, quants = c(0.5, 0.8, 0.9, 0.95, 0.99, 0.995),
mult_sc = TRUE)
load_all()
rm(list =  c("compute_conc_bm_id", "dgev_cv_fit", "fun_aggregate", "fun_aggregate2df", "get_agg_bm"))
load_all()
concbm
fit_dgev_cv_qs(agg_bm = agbm, conc_bm = concbm, ds = durs, quants = c(0.5, 0.8, 0.9, 0.95, 0.99, 0.995),
mult_sc = TRUE)
agbm
years_obs <- agg_bm[1, ]$djbm[[1]]$Year
n.years <- length(years_obs)
cvstart <- seq(years_obs[1], years_obs[n.years], n.lo)
sbst <- purrr::map(cvstart, ~ .x + (0:(n.lo -1)))
sbst[[length(sbst)]] <-  sbst[[length(sbst)]][ sbst[[length(sbst)]] <= years_obs[n.years]]
n.cv <- length(sbst)
tibres <- tibble::tibble(left_out = sbst)  %>%
dplyr::mutate( Result = purrr::map( left_out, .f = function(.x){
tryCatch(
dgev_cv_fit(agg_bm = agg_bm, conc_bm = conc_bm, leave_out = .x, ds =  ds,
quants = quants, mult_sc = mult_sc, dur_offset = dur_offset,
int_offset = int_offset, optimMethod = optimMethod, Maxit = Maxit, ... ) ,
error = function(egal){
tibble::tibble( mut = NA, sigma0 = NA, shape = NA,
eta = NA,
estimator = NA,  ps = NA, ds  = NA,
est.quants = NA, djdat = NA, quant_score = NA)
} )
}))
tibres
tibres$Result
tibres <- tibble::tibble(left_out = sbst)  %>%
dplyr::mutate( Result = purrr::map( left_out, .f = function(.x){
dgev_cv_fit(agg_bm = agg_bm, conc_bm = conc_bm, leave_out = .x, ds =  ds,
quants = quants, mult_sc = mult_sc, dur_offset = dur_offset,
int_offset = int_offset, optimMethod = optimMethod, Maxit = Maxit, ... )
}))
tibres <- tibble::tibble(left_out = sbst)  %>%
dplyr::mutate( Result = purrr::map( left_out, .f = function(.x){
dgev_cv_fit(agg_bm = agg_bm, conc_bm = conc_bm, leave_out = .x, ds =  ds,
quants = quants, mult_sc = mult_sc, dur_offset = dur_offset,
int_offset = int_offset)
}))
tibres <- tibble::tibble(left_out = sbst)  %>%
dplyr::mutate( Result = purrr::map( left_out, .f = function(.x){
dgev_cv_fit(agg_bm = agg_bm, conc_bm = conc_bm, leave_out = .x, ds =  ds,
quants = quants, mult_sc = F, dur_offset = F,
int_offset =F )
}))
tibres <- tibble::tibble(left_out = sbst)  %>%
dplyr::mutate( Result = purrr::map( left_out, .f = function(.x){
dgev_cv_fit(agg_bm = agg_bm, conc_bm = conc_bm, leave_out = .x, ds =  ds,
quants = c(.95, .99), mult_sc = F, dur_offset = F,
int_offset =F )
}))
tibres
tibres <- tibble::tibble(left_out = sbst)  %>%
dplyr::mutate( Result = purrr::map( left_out, .f = function(.x){
dgev_cv_fit(agg_bm = agg_bm, conc_bm = conc_bm, leave_out = .x, ds =  ds,
quants = c(.95, .99), mult_sc = TRUE, dur_offset = F,
int_offset =F )
}))
tibres
tibres <- tibble::tibble(left_out = sbst)  %>%
dplyr::mutate( Result = purrr::map( left_out, .f = function(.x){
tryCatch(
dgev_cv_fit(agg_bm = agg_bm, conc_bm = conc_bm, leave_out = .x, ds =  ds,
quants = quants, mult_sc =F, dur_offset = F,
int_offset = F) ,
error = function(egal){
tibble::tibble( mut = NA, sigma0 = NA, shape = NA,
eta = NA,
estimator = NA,  ps = NA, ds  = NA,
est.quants = NA, djdat = NA, quant_score = NA)
} )
}))
tibres
tibres <- tibble::tibble(left_out = sbst)  %>%
dplyr::mutate( Result = purrr::map( left_out, .f = function(.x){
tryCatch(
dgev_cv_fit(agg_bm = agg_bm, conc_bm = conc_bm, leave_out = .x, ds =  dur,
quants = c(0.95, 0.99), mult_sc =F, dur_offset = F,
int_offset = F) ,
error = function(egal){
tibble::tibble( mut = NA, sigma0 = NA, shape = NA,
eta = NA,
estimator = NA,  ps = NA, ds  = NA,
est.quants = NA, djdat = NA, quant_score = NA)
} )
}))
tibres
load_all()
fit_dgev_cv_qs(agg_bm = agbm, conc_bm = concbm, ds = durs, quants = c(0.5, 0.8, 0.9, 0.95, 0.99, 0.995),
mult_sc = TRUE)
#' example_data <- data.frame(datetime = dates, prec = prec)
#'
#' agbm <- get_agg_bm(example_data, ds = c(1,2,4,8,16, 24, 48))
#' agdf <- fun_aggregate2df( example_data, ds = c(1,2,4,8,16, 24, 48) )
#' concbm <- compute_conc_bm_id(agdf)
#' cvres <- fit_dgev_cv_qs(agbm, concbm,  ds = c(1,4,8, 24))
#' # compute mean quantile scores based on cross-validation:
#' cvres %>% dplyr::select( - c( mut, sigma0, shape, eta, conv, Testdata )) %>%
#'           dplyr::group_by(ds, ps, estimator) %>%
#'           dplyr::summarise(MQS = mean(quant_score), .groups = "drop")
fit_dgev_cv_qs <- function(agg_bm, conc_bm, ds,
quants =  1-1/c(50, 100 ), mult_sc = FALSE,
dur_offset = FALSE, int_offset = FALSE, testset = "consec",
n.lo = 3, n.cv = NULL, method = "both", returnLO = FALSE,
optimMethod = "Nelder-Mead", Maxit = 1500, ... ){
years_obs <- agg_bm[1, ]$djbm[[1]]$Year
n.years <- length(years_obs)
if(testset == "consec") {
cvstart <- seq(years_obs[1], years_obs[n.years], n.lo)
sbst <- purrr::map(cvstart, ~ .x + (0:(n.lo -1)))
sbst[[length(sbst)]] <-  sbst[[length(sbst)]][ sbst[[length(sbst)]] <= years_obs[n.years]]
n.cv <- length(sbst)
} else if( testset == "random") {
assertthat::assert_that(is.numeric(n.cv))
all.subsets <- combn(years_obs, n.lo, simplify = F)
sbst <- sample(all.subsets, min(n.cv, nrow(all.subsets)) )
n.cv <- length(sbst)
} else {
stop("This is not a valid method to construct the test set. Choose either 'consec' or 'random'")
}
tibres <- tibble::tibble(left_out = sbst)  %>%
dplyr::mutate( Result = purrr::map( left_out, .f = function(.x){
# tryCatch(
dgev_cv_fit(agg_bm = agg_bm, conc_bm = conc_bm, leave_out = .x, ds =  ds,
quants = quants, mult_sc = mult_sc, dur_offset = dur_offset,
int_offset = int_offset, optimMethod = optimMethod, Maxit = Maxit, ... )  # ,
#   error = function(egal){
#     tibble::tibble( mut = NA, sigma0 = NA, shape = NA,
#                                  eta = NA,
#                                  estimator = NA,  ps = NA, ds  = NA,
#                                  est.quants = NA, djdat = NA, quant_score = NA)
#
# } )
}))
if(!returnLO){
tibres <-   tibres %>% dplyr::select(-left_out)
}
if(!(method == "both")){
tibres <- tibres %>%
dplyr::mutate( Result = purrr::map(Result, ~ .x %>% dplyr::filter( estimator == method)))
}
tibres %>% tidyr::unnest(cols = Result)
}
fit_dgev_cv_qs(agg_bm = agbm, conc_bm = concbm, ds = durs, quants = c(0.5, 0.8, 0.9, 0.95, 0.99, 0.995),
mult_sc = TRUE)
fit_dgev_cv_qs(agg_bm = agbm, conc_bm = concbm, ds = dur, quants = c(0.5, 0.8, 0.9, 0.95, 0.99, 0.995),
mult_sc = TRUE)
#' example_data <- data.frame(datetime = dates, prec = prec)
#'
#' agbm <- get_agg_bm(example_data, ds = c(1,2,4,8,16, 24, 48))
#' agdf <- fun_aggregate2df( example_data, ds = c(1,2,4,8,16, 24, 48) )
#' concbm <- compute_conc_bm_id(agdf)
#' cvres <- fit_dgev_cv_qs(agbm, concbm,  ds = c(1,4,8, 24))
#' # compute mean quantile scores based on cross-validation:
#' cvres %>% dplyr::select( - c( mut, sigma0, shape, eta, conv, Testdata )) %>%
#'           dplyr::group_by(ds, ps, estimator) %>%
#'           dplyr::summarise(MQS = mean(quant_score), .groups = "drop")
fit_dgev_cv_qs <- function(agg_bm, conc_bm, ds,
quants =  1-1/c(50, 100 ), mult_sc = FALSE,
dur_offset = FALSE, int_offset = FALSE, testset = "consec",
n.lo = 3, n.cv = NULL, method = "both", returnLO = FALSE,
optimMethod = "Nelder-Mead", Maxit = 1500, ... ){
years_obs <- agg_bm[1, ]$djbm[[1]]$Year
n.years <- length(years_obs)
if(testset == "consec") {
cvstart <- seq(years_obs[1], years_obs[n.years], n.lo)
sbst <- purrr::map(cvstart, ~ .x + (0:(n.lo -1)))
sbst[[length(sbst)]] <-  sbst[[length(sbst)]][ sbst[[length(sbst)]] <= years_obs[n.years]]
n.cv <- length(sbst)
} else if( testset == "random") {
assertthat::assert_that(is.numeric(n.cv))
all.subsets <- combn(years_obs, n.lo, simplify = F)
sbst <- sample(all.subsets, min(n.cv, nrow(all.subsets)) )
n.cv <- length(sbst)
} else {
stop("This is not a valid method to construct the test set. Choose either 'consec' or 'random'")
}
tibres <- tibble::tibble(left_out = sbst)  %>%
dplyr::mutate( Result = purrr::map( left_out, .f = function(.x){
# tryCatch(
dgev_cv_fit(agg_bm = agg_bm, conc_bm = conc_bm, leave_out = .x, ds =  ds,
quants = quants, mult_sc = mult_sc, dur_offset = dur_offset,
int_offset = int_offset, optimMethod = optimMethod, Maxit = Maxit, ... )  ,
error = function(egal){
tibble::tibble( mut = NA, sigma0 = NA, shape = NA,
eta = NA,
estimator = NA,  ps = NA, ds  = NA,
est.quants = NA, djdat = NA, quant_score = NA)
} )
}))
if(!returnLO){
tibres <-   tibres %>% dplyr::select(-left_out)
}
if(!(method == "both")){
tibres <- tibres %>%
dplyr::mutate( Result = purrr::map(Result, ~ .x %>% dplyr::filter( estimator == method)))
}
tibres %>% tidyr::unnest(cols = Result)
}
#' example_data <- data.frame(datetime = dates, prec = prec)
#'
#' agbm <- get_agg_bm(example_data, ds = c(1,2,4,8,16, 24, 48))
#' agdf <- fun_aggregate2df( example_data, ds = c(1,2,4,8,16, 24, 48) )
#' concbm <- compute_conc_bm_id(agdf)
#' cvres <- fit_dgev_cv_qs(agbm, concbm,  ds = c(1,4,8, 24))
#' # compute mean quantile scores based on cross-validation:
#' cvres %>% dplyr::select( - c( mut, sigma0, shape, eta, conv, Testdata )) %>%
#'           dplyr::group_by(ds, ps, estimator) %>%
#'           dplyr::summarise(MQS = mean(quant_score), .groups = "drop")
fit_dgev_cv_qs <- function(agg_bm, conc_bm, ds,
quants =  1-1/c(50, 100 ), mult_sc = FALSE,
dur_offset = FALSE, int_offset = FALSE, testset = "consec",
n.lo = 3, n.cv = NULL, method = "both", returnLO = FALSE,
optimMethod = "Nelder-Mead", Maxit = 1500, ... ){
years_obs <- agg_bm[1, ]$djbm[[1]]$Year
n.years <- length(years_obs)
if(testset == "consec") {
cvstart <- seq(years_obs[1], years_obs[n.years], n.lo)
sbst <- purrr::map(cvstart, ~ .x + (0:(n.lo -1)))
sbst[[length(sbst)]] <-  sbst[[length(sbst)]][ sbst[[length(sbst)]] <= years_obs[n.years]]
n.cv <- length(sbst)
} else if( testset == "random") {
assertthat::assert_that(is.numeric(n.cv))
all.subsets <- combn(years_obs, n.lo, simplify = F)
sbst <- sample(all.subsets, min(n.cv, nrow(all.subsets)) )
n.cv <- length(sbst)
} else {
stop("This is not a valid method to construct the test set. Choose either 'consec' or 'random'")
}
tibres <- tibble::tibble(left_out = sbst)  %>%
dplyr::mutate( Result = purrr::map( left_out, .f = function(.x){
tryCatch(
dgev_cv_fit(agg_bm = agg_bm, conc_bm = conc_bm, leave_out = .x, ds =  ds,
quants = quants, mult_sc = mult_sc, dur_offset = dur_offset,
int_offset = int_offset, optimMethod = optimMethod, Maxit = Maxit, ... )  ,
error = function(egal){
tibble::tibble( mut = NA, sigma0 = NA, shape = NA,
eta = NA,
estimator = NA,  ps = NA, ds  = NA,
est.quants = NA, djdat = NA, quant_score = NA)
} )
}))
if(!returnLO){
tibres <-   tibres %>% dplyr::select(-left_out)
}
if(!(method == "both")){
tibres <- tibres %>%
dplyr::mutate( Result = purrr::map(Result, ~ .x %>% dplyr::filter( estimator == method)))
}
tibres %>% tidyr::unnest(cols = Result)
}
fit_dgev_cv_qs(agg_bm = agbm, conc_bm = concbm, ds = dur, quants = c(0.5, 0.8, 0.9, 0.95, 0.99, 0.995),
mult_sc = TRUE)
cv_res <- fit_dgev_cv_qs(agg_bm = agbm, conc_bm = concbm, ds = dur, quants = c(0.5, 0.8, 0.9, 0.95, 0.99, 0.995),
mult_sc = TRUE)
cv_res
cv_res %>% dplyr::select( - c( mut, sigma0, shape, eta, conv, Testdata )) %>%
dplyr::group_by(ds, ps, estimator) %>%
dplyr::summarise(MQS = mean(quant_score), .groups = "drop")
meanQS <-  cv_res %>% dplyr::select( - c( mut, sigma0, shape, eta, conv, Testdata )) %>%
dplyr::group_by(ds, ps, estimator) %>%
dplyr::summarise(MQS = mean(quant_score), .groups = "drop")
meanQS
meanQS %>% pivot_wider( c(estimator, MQS), names_from = estimator, values_from = MQS)
pivot_wider()
?pivot_wider()
?spread
meanQS %>% pivot_wider( names_from = estimator, values_from = MQS)
meanQS %>% pivot_wider( names_from = estimator, values_from = MQS) %>%
mutate( QSI = purrr::map2( .x = disjoint, .y = sliding, ~ compute_qsi(.y, .x)))
meanQS %>% pivot_wider( names_from = estimator, values_from = MQS) %>%
mutate( QSI = purrr::map2_dbl( .x = disjoint, .y = sliding, ~ compute_qsi(.y, .x)))
QSI <- meanQS %>% pivot_wider( names_from = estimator, values_from = MQS) %>%
mutate( QSI = purrr::map2_dbl( .x = disjoint, .y = sliding, ~ compute_qsi(.y, .x)))
QSI
QSI %>%
ggplot() +
geom_tile(aes(fill = QSI,
x= as.factor(ds),
y = as.factor(ps)), color = "black",
show.legend = TRUE)+
#  scales::seq_gradient_pal(low = "red", high = "darkblue")((1:8)/8)))+
scale_fill_gradient2()+
# scale_fill_manual(values = Cols)+
labs( x = "duration [h]", y = "Probability", fill = "QSI")+
theme_bw()+
theme(text = element_text(size= 18),
legend.key.size = unit(1.5, "cm"))
rm(list = ls())
load_all()
devtools::document()
data("precEssen")
library(IDFsl)
devtools::build_vignettes()
knitr::opts_chunk$set(
collapse = TRUE,
comment = "#>"
)
library(IDFsl)
library(tidyverse)
data("precEssen", package = "IDFsl")
head(precEssen)
precEssen <- precEssen %>% select(c(RR, MESS_DATUM)) %>%
rename("datetime" = "MESS_DATUM", "prec" = "RR")
dur <-  c(1,2,4,8,24,48, 72)
agbm <- get_agg_bm(data = precEssen, ds = dur)
QSI %>%
ggplot() +
geom_tile(aes(fill = QSI,
x= as.factor(ds),
y = as.factor(ps)), color = "black",
show.legend = TRUE)+
#  scales::seq_gradient_pal(low = "red", high = "darkblue")((1:8)/8)))+
scale_fill_gradient2()+
# scale_fill_manual(values = Cols)+
labs( x = "duration [h]", y = "Probability", fill = "QSI")+
theme_bw()+
theme(text = element_text(size= 18),
legend.key.size = unit(1.5, "cm"))
data("precEssen", package = "IDFsl")
head(precEssen)
head(precEssen)
The first column , `X`, is just a counter of observations, and we do not need it.
The functions for computing sliding block maxima of the intensity duration process
expect a tibble or data frame as input, that has *only* columns named
`datetime` containing the date and time of the measurement, as well as `prec`
containing the observed precipitation amount.
Therfore we prepare the dataset as follows
precEssen <- precEssen %>% select(c(RR, MESS_DATUM)) %>%
rename("datetime" = "MESS_DATUM", "prec" = "RR")
```{r}
dur <-  c(1,2,4,8,24,48, 72)
agbm <- get_agg_bm(data = precEssen, ds = dur)
agbm <- get_agg_bm(data = precEssen, ds = dur)
agbm
gev.d.fit.sl(agbm, mult_sc = TRUE)
agbm
gev.d.fit.sl(agbm, mult_sc = TRUE)
devtools::build_vignettes()
precSummer <- precEssen %>% filter(lubridate::month(datetime) %in% 6:8)
head(precSummer)
24*92
agbm <- get_agg_bm(data = precEssen, ds = dur, seasonlength = 92)
agdf <- fun_aggregate2df(data = precEssen, ds = dur, seasonlength = 92)
concbm <- compute_conc_bm_id(agdf, seasonlength = 92)
QSI %>%
ggplot() +
geom_tile(aes(fill = QSI,
x= as.factor(ds),
y = as.factor(ps)), color = "black",
show.legend = TRUE)+
#  scales::seq_gradient_pal(low = "red", high = "darkblue")((1:8)/8)))+
scale_fill_gradient2()+
# scale_fill_manual(values = Cols)+
labs( x = "duration [h]", y = "Probability", fill = "QSI")+
theme_bw()+
theme(text = element_text(size= 18))
cv_res <- fit_dgev_cv_qs(agg_bm = agbm, conc_bm = concbm, ds = dur,
quants = c(0.5, 0.8, 0.9, 0.95, 0.99, 0.995),
mult_sc = TRUE)
meanQS <-  cv_res %>% dplyr::select( - c( mut, sigma0, shape, eta, conv, Testdata )) %>%
dplyr::group_by(ds, ps, estimator) %>%
dplyr::summarise(MQS = mean(quant_score), .groups = "drop")
meanQS
QSI <- meanQS %>% pivot_wider( names_from = estimator, values_from = MQS) %>%
mutate( QSI = purrr::map2_dbl( .x = disjoint, .y = sliding, ~ compute_qsi(.y, .x)))
QSI
QSI %>%
ggplot() +
geom_tile(aes(fill = QSI,
x= as.factor(ds),
y = as.factor(ps)), color = "black",
show.legend = TRUE)+
scale_fill_gradient2()+
labs( x = "duration [h]", y = "Probability", fill = "QSI")+
theme_bw()+
theme(text = element_text(size= 18))
QSI %>%
ggplot() +
geom_tile(aes(fill = QSI,
x= as.factor(ds),
y = as.factor(ps)), color = "black",
show.legend = TRUE)+
#scale_fill_gradient2()+
labs( x = "duration [h]", y = "Probability", fill = "QSI")+
theme_bw()+
theme(text = element_text(size= 18))
QSI %>%
ggplot() +
geom_tile(aes(fill = max(QSI, 0.1),
x= as.factor(ds),
y = as.factor(ps)), color = "black",
show.legend = TRUE)+
scale_fill_gradient2()+
labs( x = "duration [h]", y = "Probability", fill = "QSI")+
theme_bw()+
theme(text = element_text(size= 18))
QSI %>%
ggplot() +
geom_tile(aes(fill = QSI,
x= as.factor(ds),
y = as.factor(ps)), color = "black",
show.legend = TRUE)+
scale_fill_gradient2()+
labs( x = "duration [h]", y = "Probability", fill = "QSI")+
theme_bw()+
theme(text = element_text(size= 18))
QSI %>%
ggplot() +
geom_tile(aes(fill = min(QSI, 0.1),
x= as.factor(ds),
y = as.factor(ps)), color = "black",
show.legend = TRUE)+
scale_fill_gradient2()+
labs( x = "duration [h]", y = "Probability", fill = "QSI")+
theme_bw()+
theme(text = element_text(size= 18))
QSI %>%
ggplot() +
geom_tile(aes(fill = QSI^2,
x= as.factor(ds),
y = as.factor(ps)), color = "black",
show.legend = TRUE)+
scale_fill_gradient2()+
labs( x = "duration [h]", y = "Probability", fill = "QSI")+
theme_bw()+
theme(text = element_text(size= 18))
QSI %>%
ggplot() +
geom_tile(aes(fill = QSI,
x= as.factor(ds),
y = as.factor(ps)), color = "black",
show.legend = TRUE)+
scale_fill_gradient2()+
labs( x = "duration [h]", y = "Probability", fill = "QSI")+
theme_bw()+
theme(text = element_text(size= 18))
devtools::build_vignettes()
.Last.error.trace
devtools::build_vignettes()
devtools::build_vignettes()
getwd()
devtools::install()
getwd()
usethis::use_package("tidyr")
check()
devtools::check()
.Last.error.trace
devtools::check()
devtools::check()
devtools::check()
devtools::check()
devtools::check()
devtools::build_vignettes()
.Last.error.trace
devtools::document()
devtools::build_vignettes()
devtools::build_vignettes()
usethis::use_package("dplyr")
usethis::use_package(dplyr)
devtools::load_all()
rlang::last_error()
usethis::use_package("tidyr", type = "Depends")
usethis::use_package("tidyr", type = "Imports")
devtools::document()
rlang::last_error()
usethis::use_package("dplyr")
devtools::document()
usethis::use_package(tidyverse)
usethis::use_package("tidyverse")
usethis::use_package("ggplot2")
devtools::document()
library(dplyr)
library(rlang)
install.packages("rlang")
install.packages("rlang")
install.packages("rlang")
library(rlang)
detach("package:rlang", unload = TRUE)
